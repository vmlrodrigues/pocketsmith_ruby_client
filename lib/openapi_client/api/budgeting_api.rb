=begin
#PocketSmith

#The PocketSmith API

The version of the OpenAPI document: 2.0
Contact: api@pocketsmith.com
Generated by: https://openapi-generator.tech
Generator version: 7.12.0

=end

require 'cgi'

module OpenapiClient
  class BudgetingApi
    attr_accessor :api_client

    def initialize(api_client = ApiClient.default)
      @api_client = api_client
    end
    # List budget for user
    # Lists the user's budget, consisting of one or more budget analysis packages, one per category. Akin to the list on the Budget page in PocketSmith.
    # @param id [Integer] The unique identifier of the account.
    # @param [Hash] opts the optional parameters
    # @option opts [Boolean] :roll_up Whether parent categories should have their children rolled up into them. When used, the children will still appear in the collection on their own, but their actual and forecast figures will be rolled up to the root parent.
    # @return [Array<BudgetAnalysisPackage>]
    def users_id_budget_get(id, opts = {})
      data, _status_code, _headers = users_id_budget_get_with_http_info(id, opts)
      data
    end

    # List budget for user
    # Lists the user&#39;s budget, consisting of one or more budget analysis packages, one per category. Akin to the list on the Budget page in PocketSmith.
    # @param id [Integer] The unique identifier of the account.
    # @param [Hash] opts the optional parameters
    # @option opts [Boolean] :roll_up Whether parent categories should have their children rolled up into them. When used, the children will still appear in the collection on their own, but their actual and forecast figures will be rolled up to the root parent.
    # @return [Array<(Array<BudgetAnalysisPackage>, Integer, Hash)>] Array<BudgetAnalysisPackage> data, response status code and response headers
    def users_id_budget_get_with_http_info(id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: BudgetingApi.users_id_budget_get ...'
      end
      # verify the required parameter 'id' is set
      if @api_client.config.client_side_validation && id.nil?
        fail ArgumentError, "Missing the required parameter 'id' when calling BudgetingApi.users_id_budget_get"
      end
      # resource path
      local_var_path = '/users/{id}/budget'.sub('{' + 'id' + '}', CGI.escape(id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'roll_up'] = opts[:'roll_up'] if !opts[:'roll_up'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Array<BudgetAnalysisPackage>'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['developerKey']

      new_options = opts.merge(
        :operation => :"BudgetingApi.users_id_budget_get",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: BudgetingApi#users_id_budget_get\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get budget summary for user
    # Get the user's budget summary, containing an expense and income analysis for all categories (excluding transfer categories) for the given period and date range. Akin to the overall budget shown on the Budget page in PocketSmith.
    # @param id [Integer] The unique identifier of the user.
    # @param period [String] The period to analyse in, one of &#x60;weeks&#x60;, &#x60;months&#x60; or &#x60;years&#x60;. Also supported is &#x60;event&#x60;, although event period analysis is only possible when the budget events gathered align, so in this case where all categories are analysed together, it&#39;s highly unlikely that event period analysis will be possible.
    # @param interval [Integer] The period interval, e.g. if the interval is 2 and the period is weeks, the budget will be analysed fortnightly.
    # @param start_date [String] The date to start analysing the budget from. This will be bumped out to make full periods as necessary.
    # @param end_date [String] The date to stop analysing the budget from. This will be bumped out to make full periods as necessary.
    # @param [Hash] opts the optional parameters
    # @return [Array<BudgetAnalysisPackage>]
    def users_id_budget_summary_get(id, period, interval, start_date, end_date, opts = {})
      data, _status_code, _headers = users_id_budget_summary_get_with_http_info(id, period, interval, start_date, end_date, opts)
      data
    end

    # Get budget summary for user
    # Get the user&#39;s budget summary, containing an expense and income analysis for all categories (excluding transfer categories) for the given period and date range. Akin to the overall budget shown on the Budget page in PocketSmith.
    # @param id [Integer] The unique identifier of the user.
    # @param period [String] The period to analyse in, one of &#x60;weeks&#x60;, &#x60;months&#x60; or &#x60;years&#x60;. Also supported is &#x60;event&#x60;, although event period analysis is only possible when the budget events gathered align, so in this case where all categories are analysed together, it&#39;s highly unlikely that event period analysis will be possible.
    # @param interval [Integer] The period interval, e.g. if the interval is 2 and the period is weeks, the budget will be analysed fortnightly.
    # @param start_date [String] The date to start analysing the budget from. This will be bumped out to make full periods as necessary.
    # @param end_date [String] The date to stop analysing the budget from. This will be bumped out to make full periods as necessary.
    # @param [Hash] opts the optional parameters
    # @return [Array<(Array<BudgetAnalysisPackage>, Integer, Hash)>] Array<BudgetAnalysisPackage> data, response status code and response headers
    def users_id_budget_summary_get_with_http_info(id, period, interval, start_date, end_date, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: BudgetingApi.users_id_budget_summary_get ...'
      end
      # verify the required parameter 'id' is set
      if @api_client.config.client_side_validation && id.nil?
        fail ArgumentError, "Missing the required parameter 'id' when calling BudgetingApi.users_id_budget_summary_get"
      end
      # verify the required parameter 'period' is set
      if @api_client.config.client_side_validation && period.nil?
        fail ArgumentError, "Missing the required parameter 'period' when calling BudgetingApi.users_id_budget_summary_get"
      end
      # verify enum value
      allowable_values = ["weeks", "months", "years", "event"]
      if @api_client.config.client_side_validation && !allowable_values.include?(period)
        fail ArgumentError, "invalid value for \"period\", must be one of #{allowable_values}"
      end
      # verify the required parameter 'interval' is set
      if @api_client.config.client_side_validation && interval.nil?
        fail ArgumentError, "Missing the required parameter 'interval' when calling BudgetingApi.users_id_budget_summary_get"
      end
      # verify the required parameter 'start_date' is set
      if @api_client.config.client_side_validation && start_date.nil?
        fail ArgumentError, "Missing the required parameter 'start_date' when calling BudgetingApi.users_id_budget_summary_get"
      end
      # verify the required parameter 'end_date' is set
      if @api_client.config.client_side_validation && end_date.nil?
        fail ArgumentError, "Missing the required parameter 'end_date' when calling BudgetingApi.users_id_budget_summary_get"
      end
      # resource path
      local_var_path = '/users/{id}/budget_summary'.sub('{' + 'id' + '}', CGI.escape(id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'period'] = period
      query_params[:'interval'] = interval
      query_params[:'start_date'] = start_date
      query_params[:'end_date'] = end_date

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Array<BudgetAnalysisPackage>'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['developerKey']

      new_options = opts.merge(
        :operation => :"BudgetingApi.users_id_budget_summary_get",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: BudgetingApi#users_id_budget_summary_get\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Delete forecast cache for user
    # Delete the user's cached forecast by recalculating the forecast.
    # @param id [Integer] The unique identifier of the user.
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def users_id_forecast_cache_delete(id, opts = {})
      users_id_forecast_cache_delete_with_http_info(id, opts)
      nil
    end

    # Delete forecast cache for user
    # Delete the user&#39;s cached forecast by recalculating the forecast.
    # @param id [Integer] The unique identifier of the user.
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Integer, Hash)>] nil, response status code and response headers
    def users_id_forecast_cache_delete_with_http_info(id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: BudgetingApi.users_id_forecast_cache_delete ...'
      end
      # verify the required parameter 'id' is set
      if @api_client.config.client_side_validation && id.nil?
        fail ArgumentError, "Missing the required parameter 'id' when calling BudgetingApi.users_id_forecast_cache_delete"
      end
      # resource path
      local_var_path = '/users/{id}/forecast_cache'.sub('{' + 'id' + '}', CGI.escape(id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type]

      # auth_names
      auth_names = opts[:debug_auth_names] || ['developerKey']

      new_options = opts.merge(
        :operation => :"BudgetingApi.users_id_forecast_cache_delete",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: BudgetingApi#users_id_forecast_cache_delete\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get trend analysis for user
    # Get an income and/or expense budget analysis for the given date range and period across any number of categories and scenarios. Akin to the Trends page in PocketSmith.
    # @param id [Integer] The unique identifier of the user.
    # @param period [String] The period to analyse in, one of &#x60;weeks&#x60;, &#x60;months&#x60; or &#x60;years&#x60;. Also supported is &#x60;event&#x60;, although event period analysis is only possible when the budget events gathered align, so in this case where all categories are analysed together, it&#39;s highly unlikely that event period analysis will be possible.
    # @param interval [Integer] The period interval, e.g. if the interval is 2 and the period is weeks, the budget will be analysed fortnightly.
    # @param start_date [String] The date to start analysing the budget from. This will be bumped out to make full periods as necessary.
    # @param end_date [String] The date to stop analysing the budget from. This will be bumped out to make full periods as necessary.
    # @param categories [String] A comma-separated list of category IDs to analyse.
    # @param scenarios [String] A comma-separated list of scenario IDs to analyse. You&#39;re likely going to want to include all a user&#39;s scenarios here, unless you have reason to only analyse for a subset of scenarios. Regardless of what scenarios are analysed, all actuals (transactions) across all accounts will be included.
    # @param [Hash] opts the optional parameters
    # @return [Array<BudgetAnalysisPackage>]
    def users_id_trend_analysis_get(id, period, interval, start_date, end_date, categories, scenarios, opts = {})
      data, _status_code, _headers = users_id_trend_analysis_get_with_http_info(id, period, interval, start_date, end_date, categories, scenarios, opts)
      data
    end

    # Get trend analysis for user
    # Get an income and/or expense budget analysis for the given date range and period across any number of categories and scenarios. Akin to the Trends page in PocketSmith.
    # @param id [Integer] The unique identifier of the user.
    # @param period [String] The period to analyse in, one of &#x60;weeks&#x60;, &#x60;months&#x60; or &#x60;years&#x60;. Also supported is &#x60;event&#x60;, although event period analysis is only possible when the budget events gathered align, so in this case where all categories are analysed together, it&#39;s highly unlikely that event period analysis will be possible.
    # @param interval [Integer] The period interval, e.g. if the interval is 2 and the period is weeks, the budget will be analysed fortnightly.
    # @param start_date [String] The date to start analysing the budget from. This will be bumped out to make full periods as necessary.
    # @param end_date [String] The date to stop analysing the budget from. This will be bumped out to make full periods as necessary.
    # @param categories [String] A comma-separated list of category IDs to analyse.
    # @param scenarios [String] A comma-separated list of scenario IDs to analyse. You&#39;re likely going to want to include all a user&#39;s scenarios here, unless you have reason to only analyse for a subset of scenarios. Regardless of what scenarios are analysed, all actuals (transactions) across all accounts will be included.
    # @param [Hash] opts the optional parameters
    # @return [Array<(Array<BudgetAnalysisPackage>, Integer, Hash)>] Array<BudgetAnalysisPackage> data, response status code and response headers
    def users_id_trend_analysis_get_with_http_info(id, period, interval, start_date, end_date, categories, scenarios, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: BudgetingApi.users_id_trend_analysis_get ...'
      end
      # verify the required parameter 'id' is set
      if @api_client.config.client_side_validation && id.nil?
        fail ArgumentError, "Missing the required parameter 'id' when calling BudgetingApi.users_id_trend_analysis_get"
      end
      # verify the required parameter 'period' is set
      if @api_client.config.client_side_validation && period.nil?
        fail ArgumentError, "Missing the required parameter 'period' when calling BudgetingApi.users_id_trend_analysis_get"
      end
      # verify enum value
      allowable_values = ["weeks", "months", "years", "event"]
      if @api_client.config.client_side_validation && !allowable_values.include?(period)
        fail ArgumentError, "invalid value for \"period\", must be one of #{allowable_values}"
      end
      # verify the required parameter 'interval' is set
      if @api_client.config.client_side_validation && interval.nil?
        fail ArgumentError, "Missing the required parameter 'interval' when calling BudgetingApi.users_id_trend_analysis_get"
      end
      # verify the required parameter 'start_date' is set
      if @api_client.config.client_side_validation && start_date.nil?
        fail ArgumentError, "Missing the required parameter 'start_date' when calling BudgetingApi.users_id_trend_analysis_get"
      end
      # verify the required parameter 'end_date' is set
      if @api_client.config.client_side_validation && end_date.nil?
        fail ArgumentError, "Missing the required parameter 'end_date' when calling BudgetingApi.users_id_trend_analysis_get"
      end
      # verify the required parameter 'categories' is set
      if @api_client.config.client_side_validation && categories.nil?
        fail ArgumentError, "Missing the required parameter 'categories' when calling BudgetingApi.users_id_trend_analysis_get"
      end
      # verify the required parameter 'scenarios' is set
      if @api_client.config.client_side_validation && scenarios.nil?
        fail ArgumentError, "Missing the required parameter 'scenarios' when calling BudgetingApi.users_id_trend_analysis_get"
      end
      # resource path
      local_var_path = '/users/{id}/trend_analysis'.sub('{' + 'id' + '}', CGI.escape(id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'period'] = period
      query_params[:'interval'] = interval
      query_params[:'start_date'] = start_date
      query_params[:'end_date'] = end_date
      query_params[:'categories'] = categories
      query_params[:'scenarios'] = scenarios

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Array<BudgetAnalysisPackage>'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['developerKey']

      new_options = opts.merge(
        :operation => :"BudgetingApi.users_id_trend_analysis_get",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: BudgetingApi#users_id_trend_analysis_get\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
  end
end
